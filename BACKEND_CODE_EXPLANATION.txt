# TRAINING PLACEMENT MANAGEMENT SYSTEM - DETAILED BACKEND CODE EXPLANATION

## 1. PROJECT ARCHITECTURE EXPLANATION

### Spring Boot Application Structure
```
training_placement_backend_tpms/
├── src/main/java/com/tpms/
│   ├── config/          # Configuration classes for security, CORS, etc.
│   ├── controller/      # REST API endpoints (handles HTTP requests)
│   ├── dto/            # Data Transfer Objects (for API communication)
│   ├── entity/         # Database entities (JPA mapped classes)
│   ├── enums/          # Enum constants (Role, Status, etc.)
│   ├── exception/      # Custom exception classes
│   ├── repository/     # Database access layer (JPA repositories)
│   ├── security/       # JWT authentication and authorization
│   └── service/        # Business logic layer
```

**Why this structure?**
- **Separation of Concerns**: Each layer has a specific responsibility
- **Maintainability**: Easy to locate and modify specific functionality
- **Testability**: Each layer can be tested independently
- **Scalability**: New features can be added without affecting existing code

## 2. DATABASE SCHEMA DETAILED EXPLANATION

### Users Table - Core Authentication
```sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,           -- Unique identifier for each user
    full_name VARCHAR(255) NOT NULL,                -- User's full name (required)
    email VARCHAR(255) UNIQUE NOT NULL,             -- Email (unique, used for login)
    password VARCHAR(255) NOT NULL,                 -- BCrypt hashed password
    phone VARCHAR(20),                              -- Phone number (optional)
    role ENUM('ADMIN', 'STUDENT', 'RECRUITER') NOT NULL,  -- User role for authorization
    status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE',   -- Account status
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,       -- Record creation time
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  -- Last update time
);
```

**Key Points:**
- `BIGINT AUTO_INCREMENT`: Ensures unique IDs for millions of users
- `UNIQUE` constraint on email prevents duplicate accounts
- `ENUM` for role ensures only valid roles are stored
- Timestamps track when records are created/modified

### Student Details Table - Extended Profile Information
```sql
CREATE TABLE student_details (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNIQUE,                          -- Links to users table (one-to-one)
    gender ENUM('MALE', 'FEMALE', 'OTHER'),         -- Gender information
    enrollment_no VARCHAR(50),                      -- Student enrollment number
    department VARCHAR(50),                         -- Academic department
    passing_year VARCHAR(10),                       -- Expected graduation year
    -- Personal Information
    dob VARCHAR(20),                                -- Date of birth
    age VARCHAR(5),                                 -- Current age
    -- Address Information
    address_line1 VARCHAR(255),                     -- Primary address
    address_line2 VARCHAR(255),                     -- Secondary address
    city VARCHAR(100),                              -- City
    state VARCHAR(100),                             -- State/Province
    pincode VARCHAR(10),                            -- Postal code
    nationality VARCHAR(50),                        -- Nationality
    -- Profile Links
    profile_photo TEXT,                             -- Profile photo URL/path
    linkedin_url TEXT,                              -- LinkedIn profile
    github_url TEXT,                                -- GitHub profile
    portfolio_url TEXT,                             -- Portfolio website
    -- JSON Data (flexible storage for complex data)
    education_json TEXT,                            -- Education history as JSON
    experience_json TEXT,                           -- Work experience as JSON
    skills_json TEXT,                               -- Skills list as JSON
    projects_json TEXT,                             -- Projects as JSON
    resume_links_json TEXT,                         -- Resume files as JSON
    career_interests TEXT,                          -- Career interests
    preferred_job_location VARCHAR(255),            -- Preferred work location
    placement_status VARCHAR(50),                   -- Current placement status
    profile_completed BOOLEAN DEFAULT FALSE,        -- Profile completion flag
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE  -- Cascade delete
);
```

**Key Design Decisions:**
- **JSON Fields**: Store complex data (education, skills) as JSON for flexibility
- **CASCADE DELETE**: When user is deleted, student profile is automatically deleted
- **Profile Completion Flag**: Track if student has completed their profile
- **Separate Address Fields**: Allow detailed address information

## 3. JPA ENTITIES DETAILED EXPLANATION

### User Entity - Core User Management
```java
@Entity                                    // Marks this as a JPA entity
@Table(name = "users")                     // Maps to 'users' table
@Data                                      // Lombok: generates getters, setters, toString, etc.
public class User extends BaseEntity {     // Inherits common fields (id, timestamps)
    
    @Column(name = "full_name", nullable = false)  // Maps to 'full_name' column, required
    private String fullName;
    
    @Column(unique = true, nullable = false)       // Email must be unique and not null
    private String email;
    
    @Column(nullable = false)                      // Password is required
    private String password;                       // Stored as BCrypt hash
    
    private String phone;                          // Optional field
    
    @Enumerated(EnumType.STRING)                   // Store enum as string in DB
    @Column(nullable = false)
    private Role role;                             // ADMIN, STUDENT, or RECRUITER
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Status status = Status.ACTIVE;        // Default to ACTIVE
    
    // One-to-One relationship with StudentProfile
    @OneToOne(mappedBy = "user",                   // 'user' field in StudentProfile owns the relationship
              cascade = CascadeType.ALL,           // All operations cascade to StudentProfile
              orphanRemoval = true)                // Remove StudentProfile if User is deleted
    private StudentProfile studentProfile;
}
```

**Annotations Explained:**
- `@Entity`: Tells JPA this is a database entity
- `@Table(name = "users")`: Maps to specific table name
- `@Column`: Configures column properties (nullable, unique, etc.)
- `@Enumerated(EnumType.STRING)`: Stores enum values as strings (not ordinals)
- `@OneToOne`: Defines one-to-one relationship with StudentProfile

### StudentProfile Entity - Extended Student Information
```java
@Entity
@Table(name = "student_details")
@Data
public class StudentProfile extends BaseEntity {
    
    // Owning side of the relationship
    @OneToOne(fetch = FetchType.EAGER)             // Load user data immediately
    @JoinColumn(name = "user_id", unique = true)   // Foreign key column, must be unique
    private User user;
    
    @Enumerated(EnumType.STRING)                   // Store gender as string
    private Gender gender;
    
    // Basic student information
    private String enrollmentNo;
    private String department;
    private String passingYear;
    private String dob;
    private String age;
    
    // Address fields (separate for better querying)
    private String addressLine1;
    private String addressLine2;
    private String city;
    private String state;
    private String pincode;
    private String nationality;
    
    // Profile URLs
    private String profilePhoto;
    private String linkedinUrl;
    private String githubUrl;
    private String portfolioUrl;
    
    // JSON fields for complex data
    @Column(columnDefinition = "TEXT")             // Use TEXT type for large JSON data
    private String educationJson;                  // Store education history as JSON
    
    @Column(columnDefinition = "TEXT")
    private String experienceJson;                 // Store work experience as JSON
    
    @Column(columnDefinition = "TEXT")
    private String skillsJson;                     // Store skills as JSON array
    
    @Column(columnDefinition = "TEXT")
    private String projectsJson;                   // Store projects as JSON
    
    @Column(columnDefinition = "TEXT")
    private String resumeLinksJson;                // Store resume file links as JSON
    
    @Column(columnDefinition = "TEXT")
    private String careerInterests;                // Career interests and goals
    
    private String preferredJobLocation;           // Preferred work location
    private String placementStatus;                // Current placement status
    private Boolean profileCompleted = false;     // Track profile completion
}
```

**Design Patterns Used:**
- **JSON Storage**: Complex data stored as JSON for flexibility
- **Eager Fetching**: User data loaded immediately with profile
- **Boolean Flags**: Track profile completion status
- **TEXT Columns**: Handle large JSON data efficiently

### Job Entity - Job Posting Management
```java
@Entity
@Table(name = "jobs")
@Data
public class Job extends BaseEntity {
    
    @Column(nullable = false)                      // Job title is required
    private String title;
    
    @Column(columnDefinition = "TEXT")             // Large text for job description
    private String description;
    
    private String location;                       // Job location
    private String employmentType;                 // Full-time, Part-time, Contract, etc.
    
    @Enumerated(EnumType.STRING)                   // Job status as string
    private JobStatus status = JobStatus.OPEN;    // Default to OPEN
    
    private LocalDateTime postedAt;                // When job was posted
    private String salary;                         // Salary range
    
    @Column(columnDefinition = "TEXT")
    private String skillsRequired;                 // Required skills (can be long)
    
    private String deadline;                       // Application deadline
    
    // Many-to-One relationship with Company
    @ManyToOne(fetch = FetchType.LAZY)            // Load company data only when needed
    @JoinColumn(name = "company_id")              // Foreign key to companies table
    private Company company;
    
    // One-to-Many relationship with Applications
    @OneToMany(mappedBy = "job",                  // 'job' field in Application entity
               cascade = CascadeType.ALL,          // Cascade all operations
               orphanRemoval = true)               // Remove applications when job is deleted
    private List<Application> applications = new ArrayList<>();
}
```

**Relationship Explanations:**
- **@ManyToOne**: Many jobs can belong to one company
- **@OneToMany**: One job can have many applications
- **Lazy Loading**: Company data loaded only when accessed (performance optimization)
- **Cascade Operations**: When job is deleted, all applications are also deleted

### Application Entity - Job Application Management
```java
@Entity
@Table(name = "applications")
@Data
public class Application extends BaseEntity {
    
    // Many applications can belong to one student
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id", nullable = false)  // Required foreign key
    private User student;
    
    // Many applications can be for one job
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "job_id", nullable = false)      // Required foreign key
    private Job job;
    
    @Enumerated(EnumType.STRING)                        // Application status as string
    private ApplicationStatus status = ApplicationStatus.APPLIED;  // Default status
    
    private LocalDateTime appliedAt;                    // When application was submitted
}
```

**Key Features:**
- **Composite Relationships**: Links student and job together
- **Status Tracking**: Track application progress through hiring process
- **Timestamp Tracking**: Record when application was submitted

## 4. REPOSITORY LAYER EXPLANATION

### UserRepository - Database Access for Users
```java
@Repository                                        // Spring Data JPA repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Custom query methods (Spring Data JPA generates implementation)
    Optional<User> findByEmail(String email);     // Find user by email (for login)
    boolean existsByEmail(String email);          // Check if email already exists
    List<User> findByRole(Role role);             // Find all users with specific role
    List<User> findByStatus(Status status);       // Find users by status (active/inactive)
}
```

**Spring Data JPA Magic:**
- **Automatic Implementation**: Spring generates SQL queries from method names
- **Type Safety**: Compile-time checking of query parameters
- **Optional Return**: Handles null cases gracefully
- **Boolean Methods**: Convenient existence checks

### ApplicationRepository - Complex Query Examples
```java
@Repository
public interface ApplicationRepository extends JpaRepository<Application, Long> {
    
    // Find all applications by a specific student
    List<Application> findByStudentId(Long studentId);
    
    // Find all applications for a specific job
    List<Application> findByJobId(Long jobId);
    
    // Find applications by status (for filtering)
    List<Application> findByStatus(ApplicationStatus status);
    
    // Find specific application (student + job combination)
    Optional<Application> findByStudentIdAndJobId(Long studentId, Long jobId);
    
    // Check if student already applied for job (prevent duplicates)
    boolean existsByStudentIdAndJobId(Long studentId, Long jobId);
}
```

**Query Method Naming Convention:**
- `findBy`: SELECT queries
- `existsBy`: Boolean existence checks
- `countBy`: Count queries
- `deleteBy`: DELETE queries
- Multiple conditions joined with `And`, `Or`

## 5. SERVICE LAYER EXPLANATION

### AuthService - Authentication Business Logic
```java
@Service                                           // Spring service component
@RequiredArgsConstructor                           // Lombok: constructor injection
public class AuthServiceImpl implements AuthService {
    
    private final UserRepository userRepository;   // Injected dependency
    private final PasswordEncoder passwordEncoder; // BCrypt encoder
    private final JwtUtil jwtUtil;                 // JWT token utility
    
    /**
     * User login method
     * @param loginRequest - contains email and password
     * @return LoginResponse with JWT token and user details
     */
    @Override
    public ApiResponse<LoginResponse> login(LoginRequest loginRequest) {
        try {
            // 1. Find user by email
            User user = userRepository.findByEmail(loginRequest.getEmail())
                    .orElseThrow(() -> new BadCredentialsException("Invalid credentials"));
            
            // 2. Verify password using BCrypt
            if (!passwordEncoder.matches(loginRequest.getPassword(), user.getPassword())) {
                throw new BadCredentialsException("Invalid credentials");
            }
            
            // 3. Check if user account is active
            if (user.getStatus() != Status.ACTIVE) {
                throw new AccountStatusException("Account is inactive");
            }
            
            // 4. Generate JWT token
            String token = jwtUtil.generateToken(user.getEmail(), user.getRole());
            
            // 5. Create response with user details (without password)
            LoginResponse response = LoginResponse.builder()
                    .token(token)
                    .id(user.getId())
                    .fullName(user.getFullName())
                    .email(user.getEmail())
                    .role(user.getRole())
                    .build();
            
            return new ApiResponse<>(Instant.now(), "Login successful", "SUCCESS", response);
            
        } catch (Exception e) {
            throw new AuthenticationException("Login failed: " + e.getMessage());
        }
    }
    
    /**
     * User registration method
     * @param signupRequest - contains user registration data
     * @return Success message
     */
    @Override
    public ApiResponse<String> signup(SignupRequest signupRequest) {
        try {
            // 1. Check if email already exists
            if (userRepository.existsByEmail(signupRequest.getEmail())) {
                throw new DuplicateResourceException("Email already registered");
            }
            
            // 2. Create new user entity
            User user = new User();
            user.setFullName(signupRequest.getFullName());
            user.setEmail(signupRequest.getEmail());
            user.setPassword(passwordEncoder.encode(signupRequest.getPassword())); // Hash password
            user.setPhone(signupRequest.getPhone());
            user.setRole(signupRequest.getRole());
            user.setStatus(Status.ACTIVE);
            
            // 3. Save user to database
            userRepository.save(user);
            
            return new ApiResponse<>(Instant.now(), "User registered successfully", "SUCCESS", null);
            
        } catch (Exception e) {
            throw new RegistrationException("Registration failed: " + e.getMessage());
        }
    }
}
```

**Service Layer Responsibilities:**
- **Business Logic**: Implement complex business rules
- **Validation**: Validate input data and business constraints
- **Transaction Management**: Handle database transactions
- **Exception Handling**: Convert technical exceptions to business exceptions
- **Security**: Hash passwords, generate tokens

### JobService - Job Management Business Logic
```java
@Service
@RequiredArgsConstructor
public class JobServiceImpl implements JobService {
    
    private final JobRepository jobRepository;
    private final CompanyRepository companyRepository;
    private final ModelMapper modelMapper;              // DTO mapping utility
    
    /**
     * Get all active jobs
     * @return List of job DTOs
     */
    @Override
    public ApiResponse<List<JobDto>> getAllJobs() {
        try {
            // 1. Fetch all jobs from database
            List<Job> jobs = jobRepository.findByStatus(JobStatus.OPEN);
            
            // 2. Convert entities to DTOs (hide internal details)
            List<JobDto> jobDtos = jobs.stream()
                    .map(job -> modelMapper.map(job, JobDto.class))  // Entity to DTO mapping
                    .collect(Collectors.toList());
            
            return new ApiResponse<>(Instant.now(), "Jobs retrieved successfully", "SUCCESS", jobDtos);
            
        } catch (Exception e) {
            throw new ServiceException("Failed to retrieve jobs: " + e.getMessage());
        }
    }
    
    /**
     * Create new job posting
     * @param jobDto - job data from client
     * @return Created job DTO
     */
    @Override
    @Transactional                                      // Database transaction
    public ApiResponse<JobDto> createJob(JobDto jobDto) {
        try {
            // 1. Validate company exists
            Company company = companyRepository.findById(jobDto.getCompanyId())
                    .orElseThrow(() -> new ResourceNotFoundException("Company not found"));
            
            // 2. Convert DTO to entity
            Job job = modelMapper.map(jobDto, Job.class);
            job.setCompany(company);
            job.setPostedAt(LocalDateTime.now());
            job.setStatus(JobStatus.OPEN);
            
            // 3. Save to database
            Job savedJob = jobRepository.save(job);
            
            // 4. Convert back to DTO for response
            JobDto responseDto = modelMapper.map(savedJob, JobDto.class);
            
            return new ApiResponse<>(Instant.now(), "Job created successfully", "SUCCESS", responseDto);
            
        } catch (Exception e) {
            throw new ServiceException("Failed to create job: " + e.getMessage());
        }
    }
}
```

**Key Patterns:**
- **DTO Pattern**: Separate internal entities from external API contracts
- **Transaction Management**: Ensure data consistency
- **Exception Translation**: Convert technical exceptions to business exceptions
- **Validation**: Check business rules before processing

## 6. CONTROLLER LAYER EXPLANATION

### AuthController - Authentication Endpoints
```java
@RestController                                    // REST API controller
@RequestMapping("/api/auth")                       // Base URL path
@RequiredArgsConstructor                           // Constructor injection
@CrossOrigin(origins = "http://localhost:5173")   // CORS configuration
public class AuthController {
    
    private final AuthService authService;         // Injected service
    
    /**
     * User login endpoint
     * POST /api/auth/login
     */
    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(@RequestBody LoginRequest loginRequest) {
        
        // Input validation
        if (loginRequest.getEmail() == null || loginRequest.getPassword() == null) {
            throw new BadRequestException("Email and password are required");
        }
        
        // Delegate to service layer
        ApiResponse<LoginResponse> response = authService.login(loginRequest);
        
        // Return HTTP 200 with response body
        return ResponseEntity.ok(response);
    }
    
    /**
     * User registration endpoint
     * POST /api/auth/signup
     */
    @PostMapping("/signup")
    public ResponseEntity<ApiResponse<String>> signup(@RequestBody @Valid SignupRequest signupRequest) {
        
        // @Valid annotation triggers validation
        ApiResponse<String> response = authService.signup(signupRequest);
        
        // Return HTTP 201 (Created)
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
```

**Controller Responsibilities:**
- **HTTP Handling**: Process HTTP requests and responses
- **Input Validation**: Validate request data
- **Status Codes**: Return appropriate HTTP status codes
- **CORS**: Handle cross-origin requests
- **Exception Handling**: Convert exceptions to HTTP error responses

### JobController - Job Management Endpoints
```java
@RestController
@RequestMapping("/api/jobs")
@RequiredArgsConstructor
public class JobController {
    
    private final JobService jobService;
    
    /**
     * Get all jobs - Public endpoint
     * GET /api/jobs
     */
    @GetMapping
    public ResponseEntity<ApiResponse<List<JobDto>>> getAllJobs() {
        ApiResponse<List<JobDto>> response = jobService.getAllJobs();
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get job by ID
     * GET /api/jobs/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<JobDto>> getJobById(@PathVariable Long id) {
        
        // Path variable validation
        if (id == null || id <= 0) {
            throw new BadRequestException("Invalid job ID");
        }
        
        ApiResponse<JobDto> response = jobService.getJobById(id);
        return ResponseEntity.ok(response);
    }
    
    /**
     * Create new job - Recruiter only
     * POST /api/jobs
     */
    @PostMapping
    @PreAuthorize("hasRole('RECRUITER')")          // Security annotation
    public ResponseEntity<ApiResponse<JobDto>> createJob(@RequestBody @Valid JobDto jobDto) {
        
        ApiResponse<JobDto> response = jobService.createJob(jobDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
    
    /**
     * Update job - Recruiter only
     * PUT /api/jobs/{id}
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('RECRUITER')")
    public ResponseEntity<ApiResponse<JobDto>> updateJob(@PathVariable Long id, @RequestBody @Valid JobDto jobDto) {
        
        ApiResponse<JobDto> response = jobService.updateJob(id, jobDto);
        return ResponseEntity.ok(response);
    }
    
    /**
     * Delete job - Recruiter or Admin
     * DELETE /api/jobs/{id}
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('RECRUITER') or hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deleteJob(@PathVariable Long id) {
        
        ApiResponse<Void> response = jobService.deleteJob(id);
        return ResponseEntity.ok(response);
    }
}
```

**Security Annotations:**
- `@PreAuthorize`: Method-level security
- `hasRole('RECRUITER')`: Check user role
- `hasRole('RECRUITER') or hasRole('ADMIN')`: Multiple role check

## 7. SECURITY CONFIGURATION EXPLANATION

### JWT Security Configuration
```java
@Configuration                                     // Spring configuration class
@EnableWebSecurity                                 // Enable Spring Security
@EnableMethodSecurity                              // Enable method-level security
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final JwtRequestFilter jwtRequestFilter;
    
    /**
     * Password encoder bean - BCrypt
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();        // Strong password hashing
    }
    
    /**
     * Authentication manager bean
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    /**
     * Security filter chain configuration
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // Disable CSRF for REST APIs
            .csrf(csrf -> csrf.disable())
            
            // Configure URL authorization
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**").permitAll()           // Public auth endpoints
                .requestMatchers("/api/jobs").permitAll()              // Public job listing
                .requestMatchers("/api/admin/**").hasRole("ADMIN")     // Admin only endpoints
                .requestMatchers("/api/student/**").hasRole("STUDENT") // Student only endpoints
                .requestMatchers("/api/recruiter/**").hasRole("RECRUITER") // Recruiter only
                .anyRequest().authenticated()                          // All other requests need auth
            )
            
            // Exception handling
            .exceptionHandling(ex -> ex.authenticationEntryPoint(jwtAuthenticationEntryPoint))
            
            // Stateless session (no server-side sessions)
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        
        // Add JWT filter before username/password filter
        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

**Security Features:**
- **JWT Authentication**: Stateless token-based authentication
- **Role-based Authorization**: Different access levels for different users
- **CSRF Protection**: Disabled for REST APIs (using tokens instead)
- **Stateless Sessions**: No server-side session storage

### JWT Utility Class
```java
@Component
public class JwtUtil {
    
    private String secret = "mySecretKey";         // JWT signing key (should be in config)
    private int jwtExpiration = 86400;             // 24 hours in seconds
    
    /**
     * Generate JWT token for user
     */
    public String generateToken(String email, Role role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", role.name());           // Add role to token claims
        return createToken(claims, email);
    }
    
    /**
     * Create JWT token with claims
     */
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)                 // Custom claims (role, etc.)
                .setSubject(subject)               // User identifier (email)
                .setIssuedAt(new Date(System.currentTimeMillis()))  // Issue time
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000))  // Expiry
                .signWith(SignatureAlgorithm.HS512, secret)  // Sign with secret key
                .compact();                        // Create final token string
    }
    
    /**
     * Validate JWT token
     */
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    /**
     * Extract username from token
     */
    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }
    
    /**
     * Extract role from token
     */
    public String getRoleFromToken(String token) {
        return getClaimFromToken(token, claims -> claims.get("role", String.class));
    }
    
    /**
     * Generic method to extract claims
     */
    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }
    
    /**
     * Parse all claims from token
     */
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .setSigningKey(secret)             // Use same secret for verification
                .parseClaimsJws(token)             // Parse and verify token
                .getBody();                        // Get claims
    }
    
    /**
     * Check if token is expired
     */
    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }
    
    /**
     * Get expiration date from token
     */
    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }
}
```

**JWT Token Structure:**
- **Header**: Algorithm and token type
- **Payload**: Claims (user info, role, expiry)
- **Signature**: Verification signature

## 8. DATA TRANSFER OBJECTS (DTOs) EXPLANATION

### Why Use DTOs?
1. **API Contract**: Define clear input/output contracts
2. **Security**: Hide internal entity structure
3. **Validation**: Add input validation annotations
4. **Versioning**: Support API versioning
5. **Performance**: Transfer only needed data

### LoginRequest DTO
```java
@Data                                              // Lombok: getters, setters, etc.
@NoArgsConstructor                                 // Default constructor
@AllArgsConstructor                                // All-args constructor
public class LoginRequest {
    
    @NotBlank(message = "Email is required")       // Validation annotation
    @Email(message = "Invalid email format")       // Email format validation
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;
}
```

### JobDto - Job Data Transfer Object
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder                                           // Builder pattern support
public class JobDto {
    
    private Long id;                               // Job ID (for updates)
    
    @NotBlank(message = "Job title is required")
    @Size(max = 255, message = "Title too long")
    private String title;
    
    @NotBlank(message = "Job description is required")
    private String description;
    
    @NotBlank(message = "Location is required")
    private String location;
    
    private String employmentType;                 // Full-time, Part-time, etc.
    
    @NotBlank(message = "Salary information is required")
    private String salary;
    
    private String skillsRequired;
    private String deadline;
    
    @NotNull(message = "Company ID is required")
    private Long companyId;                        // Reference to company
    
    private String companyName;                    // For display purposes
    private JobStatus status;                      // Job status
    private LocalDateTime postedAt;               // When posted
    
    // Application statistics (for recruiter view)
    private Integer totalApplications;
    private Integer shortlistedApplications;
    private Integer selectedApplications;
}
```

**DTO Features:**
- **Validation Annotations**: Ensure data quality
- **Builder Pattern**: Easy object creation
- **Display Fields**: Additional fields for UI (companyName)
- **Statistics**: Aggregated data for dashboards

## 9. EXCEPTION HANDLING EXPLANATION

### Global Exception Handler
```java
@RestControllerAdvice                              // Global exception handler
@Slf4j                                             // Logging support
public class GlobalExceptionHandler {
    
    /**
     * Handle validation errors
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Object>> handleValidationErrors(MethodArgumentNotValidException ex) {
        
        // Extract validation error messages
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ApiResponse<Object> response = new ApiResponse<>(
            Instant.now(),
            "Validation failed",
            "VALIDATION_ERROR",
            errors
        );
        
        return ResponseEntity.badRequest().body(response);
    }
    
    /**
     * Handle resource not found
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Object>> handleResourceNotFound(ResourceNotFoundException ex) {
        
        log.error("Resource not found: {}", ex.getMessage());
        
        ApiResponse<Object> response = new ApiResponse<>(
            Instant.now(),
            ex.getMessage(),
            "NOT_FOUND",
            null
        );
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    /**
     * Handle authentication errors
     */
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ApiResponse<Object>> handleAuthenticationError(AuthenticationException ex) {
        
        log.error("Authentication failed: {}", ex.getMessage());
        
        ApiResponse<Object> response = new ApiResponse<>(
            Instant.now(),
            "Authentication failed",
            "UNAUTHORIZED",
            null
        );
        
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }
    
    /**
     * Handle general exceptions
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Object>> handleGeneralException(Exception ex) {
        
        log.error("Unexpected error: ", ex);
        
        ApiResponse<Object> response = new ApiResponse<>(
            Instant.now(),
            "Internal server error",
            "ERROR",
            null
        );
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```

**Exception Handling Benefits:**
- **Consistent Response Format**: All errors return same structure
- **Proper HTTP Status Codes**: Correct status for each error type
- **Logging**: Track errors for debugging
- **Security**: Don't expose internal details

## 10. APPLICATION CONFIGURATION EXPLANATION

### application.properties - Configuration File
```properties
# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/tpms_db?useSSL=false&allowPublicKeyRetrieval=true
spring.datasource.username=root                   # Database username
spring.datasource.password=your_password          # Database password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  # MySQL driver

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update              # Auto-create/update tables
spring.jpa.show-sql=true                          # Show SQL queries in logs
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect  # MySQL dialect
spring.jpa.properties.hibernate.format_sql=true  # Format SQL in logs

# Server Configuration
server.port=8080                                  # Application port
server.servlet.context-path=/                     # Root context path

# JWT Configuration
jwt.secret=mySecretKey                            # JWT signing secret
jwt.expiration=86400                              # Token expiry (24 hours)

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB      # Max file size
spring.servlet.multipart.max-request-size=10MB   # Max request size

# Logging Configuration
logging.level.com.tpms=DEBUG                      # Debug logs for our package
logging.level.org.springframework.security=DEBUG # Security debug logs

# CORS Configuration
cors.allowed-origins=http://localhost:5173        # Frontend URL
cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS  # Allowed HTTP methods
cors.allowed-headers=*                            # Allowed headers
```

**Configuration Sections:**
- **Database**: Connection details and JPA settings
- **Server**: Port and context configuration
- **Security**: JWT settings
- **File Upload**: File size limits
- **Logging**: Debug and monitoring
- **CORS**: Cross-origin request handling

This comprehensive explanation covers all major backend components with detailed code explanations and the reasoning behind each design decision.